import{EventEmitter as A}from"events";import{getAccountsFromNamespaces as b,getSdkError as S,isValidArray as E}from"@walletconnect/utils";import{UniversalProvider as R}from"@walletconnect/universal-provider";const T="wc",$="ethereum_provider",j=`${T}@2:${$}:`,q="https://rpc.walletconnect.org/v1/",u=["eth_sendTransaction","personal_sign"],M=["eth_accounts","eth_requestAccounts","eth_sendRawTransaction","eth_sign","eth_signTransaction","eth_signTypedData","eth_signTypedData_v3","eth_signTypedData_v4","eth_sendTransaction","personal_sign","wallet_switchEthereumChain","wallet_addEthereumChain","wallet_getPermissions","wallet_requestPermissions","wallet_registerOnboarding","wallet_watchAsset","wallet_scanQRCode","wallet_sendCalls","wallet_getCapabilities","wallet_getCallsStatus","wallet_showCallsStatus"],m=["chainChanged","accountsChanged"],O=["chainChanged","accountsChanged","message","disconnect","connect"];var N=Object.defineProperty,D=Object.defineProperties,U=Object.getOwnPropertyDescriptors,P=Object.getOwnPropertySymbols,Q=Object.prototype.hasOwnProperty,L=Object.prototype.propertyIsEnumerable,y=(a,t,s)=>t in a?N(a,t,{enumerable:!0,configurable:!0,writable:!0,value:s}):a[t]=s,g=(a,t)=>{for(var s in t||(t={}))Q.call(t,s)&&y(a,s,t[s]);if(P)for(var s of P(t))L.call(t,s)&&y(a,s,t[s]);return a},_=(a,t)=>D(a,U(t)),o=(a,t,s)=>y(a,typeof t!="symbol"?t+"":t,s);function v(a){return Number(a[0].split(":")[1])}function C(a){return`0x${a.toString(16)}`}function x(a){const{chains:t,optionalChains:s,methods:i,optionalMethods:e,events:n,optionalEvents:h,rpcMap:l}=a;if(!E(t))throw new Error("Invalid chains");const r={chains:t,methods:i||u,events:n||m,rpcMap:g({},t.length?{[v(t)]:l[v(t)]}:{})},d=n?.filter(p=>!m.includes(p)),c=i?.filter(p=>!u.includes(p));if(!s&&!h&&!e&&!(d!=null&&d.length)&&!(c!=null&&c.length))return{required:t.length?r:void 0};const I=d?.length&&c?.length||!s,f={chains:[...new Set(I?r.chains.concat(s||[]):s)],methods:[...new Set(r.methods.concat(e!=null&&e.length?e:M))],events:[...new Set(r.events.concat(h!=null&&h.length?h:O))],rpcMap:l};return{required:t.length?r:void 0,optional:s.length?f:void 0}}class w{constructor(){o(this,"events",new A),o(this,"namespace","eip155"),o(this,"accounts",[]),o(this,"signer"),o(this,"chainId",1),o(this,"modal"),o(this,"rpc"),o(this,"STORAGE_KEY",j),o(this,"on",(t,s)=>(this.events.on(t,s),this)),o(this,"once",(t,s)=>(this.events.once(t,s),this)),o(this,"removeListener",(t,s)=>(this.events.removeListener(t,s),this)),o(this,"off",(t,s)=>(this.events.off(t,s),this)),o(this,"parseAccount",t=>this.isCompatibleChainId(t)?this.parseAccountId(t).address:t),this.signer={},this.rpc={}}static async init(t){const s=new w;return await s.initialize(t),s}async request(t,s){return await this.signer.request(t,this.formatChainId(this.chainId),s)}sendAsync(t,s,i){this.signer.sendAsync(t,s,this.formatChainId(this.chainId),i)}get connected(){return this.signer.client?this.signer.client.core.relayer.connected:!1}get connecting(){return this.signer.client?this.signer.client.core.relayer.connecting:!1}async enable(){return this.session||await this.connect(),await this.request({method:"eth_requestAccounts"})}async connect(t){if(!this.signer.client)throw new Error("Provider not initialized. Call init() first");this.loadConnectOpts(t);const{required:s,optional:i}=x(this.rpc);try{const e=await new Promise(async(h,l)=>{var r;this.rpc.showQrModal&&((r=this.modal)==null||r.subscribeModal(c=>{!c.open&&!this.signer.session&&(this.signer.abortPairingAttempt(),l(new Error("Connection request reset. Please try again.")))}));const d=t!=null&&t.scopedProperties?{[this.namespace]:t.scopedProperties}:void 0;await this.signer.connect(_(g({namespaces:g({},s&&{[this.namespace]:s})},i&&{optionalNamespaces:{[this.namespace]:i}}),{pairingTopic:t?.pairingTopic,scopedProperties:d})).then(c=>{h(c)}).catch(c=>{l(new Error(c.message))})});if(!e)return;const n=b(e.namespaces,[this.namespace]);this.setChainIds(this.rpc.chains.length?this.rpc.chains:n),this.setAccounts(n),this.events.emit("connect",{chainId:C(this.chainId)})}catch(e){throw this.signer.logger.error(e),e}finally{this.modal&&this.modal.closeModal()}}async authenticate(t,s){if(!this.signer.client)throw new Error("Provider not initialized. Call init() first");this.loadConnectOpts({chains:t?.chains});try{const i=await new Promise(async(n,h)=>{var l;this.rpc.showQrModal&&((l=this.modal)==null||l.subscribeModal(r=>{!r.open&&!this.signer.session&&(this.signer.abortPairingAttempt(),h(new Error("Connection request reset. Please try again.")))})),await this.signer.authenticate(_(g({},t),{chains:this.rpc.chains}),s).then(r=>{n(r)}).catch(r=>{h(new Error(r.message))})}),e=i.session;if(e){const n=b(e.namespaces,[this.namespace]);this.setChainIds(this.rpc.chains.length?this.rpc.chains:n),this.setAccounts(n),this.events.emit("connect",{chainId:C(this.chainId)})}return i}catch(i){throw this.signer.logger.error(i),i}finally{this.modal&&this.modal.closeModal()}}async disconnect(){this.session&&await this.signer.disconnect(),this.reset()}get isWalletConnect(){return!0}get session(){return this.signer.session}registerEventListeners(){this.signer.on("session_event",t=>{const{params:s}=t,{event:i}=s;i.name==="accountsChanged"?(this.accounts=this.parseAccounts(i.data),this.events.emit("accountsChanged",this.accounts)):i.name==="chainChanged"?this.setChainId(this.formatChainId(i.data)):this.events.emit(i.name,i.data),this.events.emit("session_event",t)}),this.signer.on("accountsChanged",t=>{this.accounts=this.parseAccounts(t),this.events.emit("accountsChanged",this.accounts)}),this.signer.on("chainChanged",t=>{const s=parseInt(t);this.chainId=s,this.events.emit("chainChanged",C(this.chainId)),this.persist()}),this.signer.on("session_update",t=>{this.events.emit("session_update",t)}),this.signer.on("session_delete",t=>{this.reset(),this.events.emit("session_delete",t),this.events.emit("disconnect",_(g({},S("USER_DISCONNECTED")),{data:t.topic,name:"USER_DISCONNECTED"}))}),this.signer.on("display_uri",t=>{var s,i;this.rpc.showQrModal&&((s=this.modal)==null||s.closeModal(),(i=this.modal)==null||i.openModal({uri:t})),this.events.emit("display_uri",t)})}switchEthereumChain(t){this.request({method:"wallet_switchEthereumChain",params:[{chainId:t.toString(16)}]})}isCompatibleChainId(t){return typeof t=="string"?t.startsWith(`${this.namespace}:`):!1}formatChainId(t){return`${this.namespace}:${t}`}parseChainId(t){return Number(t.split(":")[1])}setChainIds(t){const s=t.filter(i=>this.isCompatibleChainId(i)).map(i=>this.parseChainId(i));s.length&&(this.chainId=s[0],this.events.emit("chainChanged",C(this.chainId)),this.persist())}setChainId(t){if(this.isCompatibleChainId(t)){const s=this.parseChainId(t);this.chainId=s,this.switchEthereumChain(s)}}parseAccountId(t){const[s,i,e]=t.split(":");return{chainId:`${s}:${i}`,address:e}}setAccounts(t){this.accounts=t.filter(s=>this.parseChainId(this.parseAccountId(s).chainId)===this.chainId).map(s=>this.parseAccountId(s).address),this.events.emit("accountsChanged",this.accounts)}getRpcConfig(t){var s,i;const e=(s=t?.chains)!=null?s:[],n=(i=t?.optionalChains)!=null?i:[],h=e.concat(n);if(!h.length)throw new Error("No chains specified in either `chains` or `optionalChains`");const l=e.length?t?.methods||u:[],r=e.length?t?.events||m:[],d=t?.optionalMethods||[],c=t?.optionalEvents||[],I=t?.rpcMap||this.buildRpcMap(h,t.projectId),f=t?.qrModalOptions||void 0;return{chains:e?.map(p=>this.formatChainId(p)),optionalChains:n.map(p=>this.formatChainId(p)),methods:l,events:r,optionalMethods:d,optionalEvents:c,rpcMap:I,showQrModal:!!(t!=null&&t.showQrModal),qrModalOptions:f,projectId:t.projectId,metadata:t.metadata}}buildRpcMap(t,s){const i={};return t.forEach(e=>{i[e]=this.getRpcUrl(e,s)}),i}async initialize(t){if(this.rpc=this.getRpcConfig(t),this.chainId=this.rpc.chains.length?v(this.rpc.chains):v(this.rpc.optionalChains),this.signer=await R.init({projectId:this.rpc.projectId,metadata:this.rpc.metadata,disableProviderPing:t.disableProviderPing,relayUrl:t.relayUrl,storage:t.storage,storageOptions:t.storageOptions,customStoragePrefix:t.customStoragePrefix,telemetryEnabled:t.telemetryEnabled,logger:t.logger}),this.registerEventListeners(),await this.loadPersistedSession(),this.rpc.showQrModal){let s;try{const{WalletConnectModal:i}=await import("@walletconnect/modal");s=i}catch{throw new Error("To use QR modal, please install @walletconnect/modal package")}if(s)try{this.modal=new s(g({projectId:this.rpc.projectId},this.rpc.qrModalOptions))}catch(i){throw this.signer.logger.error(i),new Error("Could not generate WalletConnectModal Instance")}}}loadConnectOpts(t){if(!t)return;const{chains:s,optionalChains:i,rpcMap:e}=t;s&&E(s)&&(this.rpc.chains=s.map(n=>this.formatChainId(n)),s.forEach(n=>{this.rpc.rpcMap[n]=e?.[n]||this.getRpcUrl(n)})),i&&E(i)&&(this.rpc.optionalChains=[],this.rpc.optionalChains=i?.map(n=>this.formatChainId(n)),i.forEach(n=>{this.rpc.rpcMap[n]=e?.[n]||this.getRpcUrl(n)}))}getRpcUrl(t,s){var i;return((i=this.rpc.rpcMap)==null?void 0:i[t])||`${q}?chainId=eip155:${t}&projectId=${s||this.rpc.projectId}`}async loadPersistedSession(){if(this.session)try{const t=await this.signer.client.core.storage.getItem(`${this.STORAGE_KEY}/chainId`),s=this.session.namespaces[`${this.namespace}:${t}`]?this.session.namespaces[`${this.namespace}:${t}`]:this.session.namespaces[this.namespace];this.setChainIds(t?[this.formatChainId(t)]:s?.accounts),this.setAccounts(s?.accounts)}catch(t){this.signer.logger.error("Failed to load persisted session, clearing state..."),this.signer.logger.error(t),await this.disconnect().catch(s=>this.signer.logger.warn(s))}}reset(){this.chainId=1,this.accounts=[]}persist(){this.session&&this.signer.client.core.storage.setItem(`${this.STORAGE_KEY}/chainId`,this.chainId)}parseAccounts(t){return typeof t=="string"||t instanceof String?[this.parseAccount(t)]:t.map(s=>this.parseAccount(s))}}const z=w;export{z as EthereumProvider,O as OPTIONAL_EVENTS,M as OPTIONAL_METHODS,m as REQUIRED_EVENTS,u as REQUIRED_METHODS,w as default};
//# sourceMappingURL=index.es.js.map
