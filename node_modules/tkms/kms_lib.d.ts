/* tslint:disable */
/* eslint-disable */
/**
 * @param {PublicSigKey} pk
 * @returns {Uint8Array}
 */
export function public_sig_key_to_u8vec(pk: PublicSigKey): Uint8Array;
/**
 * @param {Uint8Array} v
 * @returns {PublicSigKey}
 */
export function u8vec_to_public_sig_key(v: Uint8Array): PublicSigKey;
/**
 * @param {PrivateSigKey} sk
 * @returns {Uint8Array}
 */
export function private_sig_key_to_u8vec(sk: PrivateSigKey): Uint8Array;
/**
 * @param {Uint8Array} v
 * @returns {PrivateSigKey}
 */
export function u8vec_to_private_sig_key(v: Uint8Array): PrivateSigKey;
/**
 * Instantiate a new client.
 *
 * * `server_addrs` - a list of KMS server EIP-55 addresses,
 * must be prefixed with "0x".
 *
 * * `client_address_hex` - the client (wallet) address in hex,
 * must be prefixed with "0x".
 *
 * * `param_choice` - the parameter choice, which can be either `"test"` or `"default"`.
 * The "default" parameter choice is selected if no matching string is found.
 * @param {(string)[]} server_addrs
 * @param {string} client_address_hex
 * @param {string} param_choice
 * @returns {Client}
 */
export function new_client(server_addrs: (string)[], client_address_hex: string, param_choice: string): Client;
/**
 * @param {Client} client
 * @returns {(string)[]}
 */
export function get_server_addrs(client: Client): (string)[];
/**
 * @param {Client} client
 * @returns {PrivateSigKey | undefined}
 */
export function get_client_secret_key(client: Client): PrivateSigKey | undefined;
/**
 * @param {Client} client
 * @returns {string}
 */
export function get_client_address(client: Client): string;
/**
 * @returns {PrivateEncKey}
 */
export function cryptobox_keygen(): PrivateEncKey;
/**
 * @param {PrivateEncKey} sk
 * @returns {PublicEncKey}
 */
export function cryptobox_get_pk(sk: PrivateEncKey): PublicEncKey;
/**
 * @param {PublicEncKey} pk
 * @returns {Uint8Array}
 */
export function cryptobox_pk_to_u8vec(pk: PublicEncKey): Uint8Array;
/**
 * @param {PrivateEncKey} sk
 * @returns {Uint8Array}
 */
export function cryptobox_sk_to_u8vec(sk: PrivateEncKey): Uint8Array;
/**
 * @param {Uint8Array} v
 * @returns {PublicEncKey}
 */
export function u8vec_to_cryptobox_pk(v: Uint8Array): PublicEncKey;
/**
 * @param {Uint8Array} v
 * @returns {PrivateEncKey}
 */
export function u8vec_to_cryptobox_sk(v: Uint8Array): PrivateEncKey;
/**
 * @param {Uint8Array} msg
 * @param {PublicEncKey} their_pk
 * @param {PrivateEncKey} my_sk
 * @returns {CryptoBoxCt}
 */
export function cryptobox_encrypt(msg: Uint8Array, their_pk: PublicEncKey, my_sk: PrivateEncKey): CryptoBoxCt;
/**
 * @param {CryptoBoxCt} ct
 * @param {PrivateEncKey} my_sk
 * @param {PublicEncKey} their_pk
 * @returns {Uint8Array}
 */
export function cryptobox_decrypt(ct: CryptoBoxCt, my_sk: PrivateEncKey, their_pk: PublicEncKey): Uint8Array;
/**
 * Process the reencryption response from JavaScript objects.
 * The returned result is a byte array representing a plaintext of any length,
 * postprocessing is returned to turn it into an integer.
 *
 * * `client` - client that wants to perform reencryption.
 *
 * * `request` - the initial reencryption request JS object.
 * It can be set to null if `verify` is false.
 * Otherwise the caller needs to give the following JS object.
 * Note that `client_address` and `eip712_verifying_contract` follow EIP-55.
 * ```
 * {
 *   signature: '15a4f9a8eb61459cfba7d103d8f911fb04ce91ecf841b34c49c0d56a70b896d20cbc31986188f91efc3842b7df215cee8acb40178daedb8b63d0ba5d199bce121c',
 *   client_address: '0x17853A630aAe15AED549B2B874de08B73C0F59c5',
 *   enc_key: '2000000000000000df2fcacb774f03187f3802a27259f45c06d33cefa68d9c53426b15ad531aa822',
 *   ciphertext_handle: '0748b542afe2353c86cb707e3d21044b0be1fd18efc7cbaa6a415af055bfb358',
 *   eip712_verifying_contract: '0x66f9664f97F2b50F62D13eA064982f936dE76657'
 * }
 * ```
 *
 * * `eip712_domain` - the EIP-712 domain JS object.
 * It can be set to null if `verify` is false.
 * Otherwise the caller needs to give the following JS object.
 * Note that `salt` is optional and `verifying_contract` follows EIP-55,
 * additionally, `chain_id` is an array of u8.
 * ```
 * {
 *   name: 'Authorization token',
 *   version: '1',
 *   chain_id: [
 *     70, 31, 0, 0, 0, 0, 0, 0, 0,
 *      0,  0, 0, 0, 0, 0, 0, 0, 0,
 *      0,  0, 0, 0, 0, 0, 0, 0, 0,
 *      0,  0, 0, 0, 0
 *   ],
 *   verifying_contract: '0x66f9664f97F2b50F62D13eA064982f936dE76657',
 *   salt: []
 * }
 * ```
 *
 * * `agg_resp` - the response JS object from the gateway.
 * It has two fields like so, both are hex encoded byte arrays.
 * ```
 * [
 *   {
 *     signature: '69e7e040cab157aa819015b321c012dccb1545ffefd325b359b492653f0347517e28e66c572cdc299e259024329859ff9fcb0096e1ce072af0b6e1ca1fe25ec6',
 *     payload: '0100000029...'
 *   }
 * ]
 * ```
 *
 * * `enc_pk` - The ephemeral public key.
 *
 * * `enc_sk` - The ephemeral secret key.
 *
 * * `verify` - Whether to perform signature verification for the response.
 * It is insecure if `verify = false`!
 * @param {Client} client
 * @param {any} request
 * @param {any} eip712_domain
 * @param {any} agg_resp
 * @param {PublicEncKey} enc_pk
 * @param {PrivateEncKey} enc_sk
 * @param {boolean} verify
 * @returns {Uint8Array}
 */
export function process_reencryption_resp_from_js(client: Client, request: any, eip712_domain: any, agg_resp: any, enc_pk: PublicEncKey, enc_sk: PrivateEncKey, verify: boolean): Uint8Array;
/**
 * Process the reencryption response from Rust objects.
 * Consider using [process_reencryption_resp_from_js]
 * when using the JS API.
 * The result is a byte array representing a plaintext of any length.
 *
 * * `client` - client that wants to perform reencryption.
 *
 * * `request` - the initial reencryption request.
 * Must be given if `verify` is true.
 *
 * * `eip712_domain` - the EIP-712 domain.
 * Must be given if `verify` is true.
 *
 * * `agg_resp` - the vector of reencryption responses.
 *
 * * `enc_pk` - The ephemeral public key.
 *
 * * `enc_sk` - The ephemeral secret key.
 *
 * * `verify` - Whether to perform signature verification for the response.
 * It is insecure if `verify = false`!
 * @param {Client} client
 * @param {ParsedReencryptionRequest | undefined} request
 * @param {Eip712DomainMsg | undefined} eip712_domain
 * @param {(ReencryptionResponse)[]} agg_resp
 * @param {PublicEncKey} enc_pk
 * @param {PrivateEncKey} enc_sk
 * @param {boolean} verify
 * @returns {Uint8Array}
 */
export function process_reencryption_resp(client: Client, request: ParsedReencryptionRequest | undefined, eip712_domain: Eip712DomainMsg | undefined, agg_resp: (ReencryptionResponse)[], enc_pk: PublicEncKey, enc_sk: PrivateEncKey, verify: boolean): Uint8Array;
/**
 * The plaintext types that can be encrypted in a fhevm ciphertext.
 */
export enum FheType {
  Ebool = 0,
  Euint4 = 1,
  Euint8 = 2,
  Euint16 = 3,
  Euint32 = 4,
  Euint64 = 5,
  Euint128 = 6,
  Euint160 = 7,
  Euint256 = 8,
  Euint512 = 9,
  Euint1024 = 10,
  Euint2048 = 11,
}
/**
 * Core Client
 *
 * Simple client to interact with the KMS servers. This can be seen as a proof-of-concept
 * and reference code for validating the KMS. The logic supplied by the client will be
 * distributed across the aggregator/proxy and smart contracts.
 */
export class Client {
  free(): void;
}
export class CryptoBoxCt {
  free(): void;
}
/**
 * <https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator>
 * eventually chain_id, verifying_contract and salt will be parsed in to
 * solidity types
 */
export class Eip712DomainMsg {
  free(): void;
  chain_id: Uint8Array;
  name: string;
  salt?: Uint8Array;
  verifying_contract: string;
  version: string;
}
/**
 * Validity of this struct is not checked.
 */
export class ParsedReencryptionRequest {
  free(): void;
}
export class PrivateEncKey {
  free(): void;
}
export class PrivateSigKey {
  free(): void;
}
export class PublicEncKey {
  free(): void;
}
export class PublicSigKey {
  free(): void;
}
export class ReencryptionRequest {
  free(): void;
  domain?: Eip712DomainMsg;
  payload?: ReencryptionRequestPayload;
/**
 * The ID that identifies this request.
 * Future queries for the result must use this request ID.
 */
  request_id?: RequestId;
/**
 * Signature of the serialization of \[ReencryptionRequestPayload\].
 */
  signature: Uint8Array;
}
export class ReencryptionRequestPayload {
  free(): void;
/**
 * The actual ciphertext to decrypt, taken directly from the fhevm.
 * When creating the payload, this field may be empty,
 * it is the responsibility of the gateway to fetch the
 * ciphertext for the given digest below.
 */
  ciphertext?: Uint8Array;
/**
 * The SHA3 digest of the ciphertext above.
 */
  ciphertext_digest: Uint8Array;
/**
 * The client's (blockchain wallet) address,
 * encoded using EIP-55.
 */
  client_address: string;
/**
 * Encoding of the user's public encryption key for this request.
 * Encoding using the default encoding of libsodium, i.e. the 32 bytes of a
 * Montgomery point.
 */
  enc_key: Uint8Array;
/**
 * The type of plaintext encrypted.
 */
  fhe_type: number;
/**
 * The key id to use for decryption. Will be the request_id used during key
 * generation
 */
  key_id?: RequestId;
/**
 * Version of the request format.
 */
  version: number;
}
export class ReencryptionResponse {
  free(): void;
/**
 * Signature of the serialization of \[ReencryptionResponsePayload\].
 */
  payload?: ReencryptionResponsePayload;
  signature: Uint8Array;
}
export class ReencryptionResponsePayload {
  free(): void;
/**
 * The degree of the sharing scheme used.
 */
  degree: number;
/**
 * The concatenation of two digests:
 * (eip712_signing_hash(pk, domain) || ciphertext digest).
 * This is needed to ensure the response corresponds to the request.
 */
  digest: Uint8Array;
/**
 * The type of plaintext encrypted.
 */
  fhe_type: number;
/**
 * The ID of the MPC party doing the reencryption. Used for polynomial
 * reconstruction.
 */
  party_id: number;
/**
 * The signcrypted payload, using a hybrid encryption approach in
 * sign-then-encrypt.
 */
  signcrypted_ciphertext: Uint8Array;
/**
 * The server's signature verification key.
 * Encoded using SEC1.
 * Needed to validate the response, but MUST also be linked to a list of
 * trusted keys.
 */
  verification_key: Uint8Array;
/**
 * Version of the response format.
 */
  version: number;
}
/**
 * Simple response to return an ID, to be used to retrieve the computed result
 * later on.
 */
export class RequestId {
  free(): void;
  request_id: string;
}

export type InitInput = RequestInfo | URL | Response | BufferSource | WebAssembly.Module;

export interface InitOutput {
  readonly memory: WebAssembly.Memory;
  readonly __wbg_client_free: (a: number, b: number) => void;
  readonly __wbg_parsedreencryptionrequest_free: (a: number, b: number) => void;
  readonly public_sig_key_to_u8vec: (a: number) => Array;
  readonly u8vec_to_public_sig_key: (a: number, b: number) => Array;
  readonly private_sig_key_to_u8vec: (a: number) => Array;
  readonly u8vec_to_private_sig_key: (a: number, b: number) => Array;
  readonly new_client: (a: number, b: number, c: number, d: number, e: number, f: number) => Array;
  readonly get_server_addrs: (a: number) => Array;
  readonly get_client_secret_key: (a: number) => number;
  readonly get_client_address: (a: number) => Array;
  readonly __wbg_cryptoboxct_free: (a: number, b: number) => void;
  readonly cryptobox_keygen: () => number;
  readonly cryptobox_get_pk: (a: number) => number;
  readonly cryptobox_pk_to_u8vec: (a: number) => Array;
  readonly cryptobox_sk_to_u8vec: (a: number) => Array;
  readonly u8vec_to_cryptobox_pk: (a: number, b: number) => Array;
  readonly u8vec_to_cryptobox_sk: (a: number, b: number) => Array;
  readonly cryptobox_encrypt: (a: number, b: number, c: number, d: number) => number;
  readonly cryptobox_decrypt: (a: number, b: number, c: number) => Array;
  readonly process_reencryption_resp_from_js: (a: number, b: number, c: number, d: number, e: number, f: number, g: number) => Array;
  readonly process_reencryption_resp: (a: number, b: number, c: number, d: number, e: number, f: number, g: number, h: number) => Array;
  readonly __wbg_requestid_free: (a: number, b: number) => void;
  readonly __wbg_reencryptionrequestpayload_free: (a: number, b: number) => void;
  readonly __wbg_get_reencryptionrequestpayload_version: (a: number) => number;
  readonly __wbg_set_reencryptionrequestpayload_version: (a: number, b: number) => void;
  readonly __wbg_get_reencryptionrequestpayload_enc_key: (a: number) => Array;
  readonly __wbg_get_reencryptionrequestpayload_fhe_type: (a: number) => number;
  readonly __wbg_set_reencryptionrequestpayload_fhe_type: (a: number, b: number) => void;
  readonly __wbg_get_reencryptionrequestpayload_key_id: (a: number) => number;
  readonly __wbg_set_reencryptionrequestpayload_key_id: (a: number, b: number) => void;
  readonly __wbg_eip712domainmsg_free: (a: number, b: number) => void;
  readonly __wbg_get_eip712domainmsg_name: (a: number) => Array;
  readonly __wbg_set_eip712domainmsg_name: (a: number, b: number, c: number) => void;
  readonly __wbg_get_eip712domainmsg_version: (a: number) => Array;
  readonly __wbg_set_eip712domainmsg_version: (a: number, b: number, c: number) => void;
  readonly __wbg_get_eip712domainmsg_chain_id: (a: number) => Array;
  readonly __wbg_set_eip712domainmsg_chain_id: (a: number, b: number, c: number) => void;
  readonly __wbg_get_eip712domainmsg_verifying_contract: (a: number) => Array;
  readonly __wbg_set_eip712domainmsg_verifying_contract: (a: number, b: number, c: number) => void;
  readonly __wbg_get_eip712domainmsg_salt: (a: number) => Array;
  readonly __wbg_set_eip712domainmsg_salt: (a: number, b: number, c: number) => void;
  readonly __wbg_reencryptionrequest_free: (a: number, b: number) => void;
  readonly __wbg_get_reencryptionrequest_signature: (a: number) => Array;
  readonly __wbg_get_reencryptionrequest_payload: (a: number) => number;
  readonly __wbg_set_reencryptionrequest_payload: (a: number, b: number) => void;
  readonly __wbg_get_reencryptionrequest_domain: (a: number) => number;
  readonly __wbg_set_reencryptionrequest_domain: (a: number, b: number) => void;
  readonly __wbg_get_reencryptionrequest_request_id: (a: number) => number;
  readonly __wbg_set_reencryptionrequest_request_id: (a: number, b: number) => void;
  readonly __wbg_reencryptionresponse_free: (a: number, b: number) => void;
  readonly __wbg_get_reencryptionresponse_payload: (a: number) => number;
  readonly __wbg_set_reencryptionresponse_payload: (a: number, b: number) => void;
  readonly __wbg_reencryptionresponsepayload_free: (a: number, b: number) => void;
  readonly __wbg_get_reencryptionresponsepayload_version: (a: number) => number;
  readonly __wbg_set_reencryptionresponsepayload_version: (a: number, b: number) => void;
  readonly __wbg_get_reencryptionresponsepayload_fhe_type: (a: number) => number;
  readonly __wbg_set_reencryptionresponsepayload_fhe_type: (a: number, b: number) => void;
  readonly __wbg_get_reencryptionresponsepayload_party_id: (a: number) => number;
  readonly __wbg_set_reencryptionresponsepayload_party_id: (a: number, b: number) => void;
  readonly __wbg_get_reencryptionresponsepayload_degree: (a: number) => number;
  readonly __wbg_set_reencryptionresponsepayload_degree: (a: number, b: number) => void;
  readonly __wbg_set_requestid_request_id: (a: number, b: number, c: number) => void;
  readonly __wbg_set_reencryptionrequestpayload_client_address: (a: number, b: number, c: number) => void;
  readonly __wbg_set_reencryptionrequestpayload_enc_key: (a: number, b: number, c: number) => void;
  readonly __wbg_set_reencryptionrequestpayload_ciphertext_digest: (a: number, b: number, c: number) => void;
  readonly __wbg_set_reencryptionrequest_signature: (a: number, b: number, c: number) => void;
  readonly __wbg_set_reencryptionresponse_signature: (a: number, b: number, c: number) => void;
  readonly __wbg_set_reencryptionresponsepayload_verification_key: (a: number, b: number, c: number) => void;
  readonly __wbg_set_reencryptionresponsepayload_digest: (a: number, b: number, c: number) => void;
  readonly __wbg_set_reencryptionresponsepayload_signcrypted_ciphertext: (a: number, b: number, c: number) => void;
  readonly __wbg_set_reencryptionrequestpayload_ciphertext: (a: number, b: number, c: number) => void;
  readonly __wbg_get_reencryptionrequestpayload_ciphertext: (a: number) => Array;
  readonly __wbg_get_reencryptionrequestpayload_ciphertext_digest: (a: number) => Array;
  readonly __wbg_get_reencryptionresponse_signature: (a: number) => Array;
  readonly __wbg_get_reencryptionresponsepayload_verification_key: (a: number) => Array;
  readonly __wbg_get_reencryptionresponsepayload_digest: (a: number) => Array;
  readonly __wbg_get_reencryptionresponsepayload_signcrypted_ciphertext: (a: number) => Array;
  readonly __wbg_get_requestid_request_id: (a: number) => Array;
  readonly __wbg_get_reencryptionrequestpayload_client_address: (a: number) => Array;
  readonly __wbg_publicenckey_free: (a: number, b: number) => void;
  readonly __wbg_privateenckey_free: (a: number, b: number) => void;
  readonly __wbg_publicsigkey_free: (a: number, b: number) => void;
  readonly __wbg_privatesigkey_free: (a: number, b: number) => void;
  readonly __wbindgen_malloc: (a: number, b: number) => number;
  readonly __wbindgen_realloc: (a: number, b: number, c: number, d: number) => number;
  readonly __wbindgen_export_2: WebAssembly.Table;
  readonly __wbindgen_free: (a: number, b: number, c: number) => void;
  readonly __externref_table_dealloc: (a: number) => void;
  readonly __externref_table_alloc: () => number;
  readonly __externref_drop_slice: (a: number, b: number) => void;
  readonly __wbindgen_exn_store: (a: number) => void;
  readonly __wbindgen_start: () => void;
}

export type SyncInitInput = BufferSource | WebAssembly.Module;
/**
* Instantiates the given `module`, which can either be bytes or
* a precompiled `WebAssembly.Module`.
*
* @param {{ module: SyncInitInput }} module - Passing `SyncInitInput` directly is deprecated.
*
* @returns {InitOutput}
*/
export function initSync(module: { module: SyncInitInput } | SyncInitInput): InitOutput;

/**
* If `module_or_path` is {RequestInfo} or {URL}, makes a request and
* for everything else, calls `WebAssembly.instantiate` directly.
*
* @param {{ module_or_path: InitInput | Promise<InitInput> }} module_or_path - Passing `InitInput` directly is deprecated.
*
* @returns {Promise<InitOutput>}
*/
export default function __wbg_init (module_or_path?: { module_or_path: InitInput | Promise<InitInput> } | InitInput | Promise<InitInput>): Promise<InitOutput>;
